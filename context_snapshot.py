import os
import sys
import fnmatch
import re
from collections import defaultdict

# --- Pre-defined Exclusion Presets ---
COMMON_EXCLUSIONS = [
    '.git', '.vscode', '.idea', 'gradle', 'Thumbs.db', '.DS_Store',
    '.gitignore'
]
ROOT_LEVEL_EXCLUSIONS = [
    'LICENSE*', 'LICENCE*', 'COPYING*',
    'gradlew', 'gradlew.bat',
    '.gitattributes',
]
PYTHON_EXCLUSIONS = COMMON_EXCLUSIONS + ['__pycache__', 'venv', '.venv', '*.pyc', '.env', 'dist', 'build']
NODE_EXCLUSIONS = COMMON_EXCLUSIONS + ['node_modules', 'dist', 'build', '.env', 'package-lock.json', 'yarn.lock']
ANDROID_EXCLUSIONS = COMMON_EXCLUSIONS + [
    '.gradle', 'build', '.cxx', 'local.properties', '*.apk', '*.aar',
    '*.jar', '*.keystore', '*.jks', 'captures'
]

# --- HELPER FUNCTIONS ---
def normalize_pattern(pattern, root_path):
    """
    Converts absolute paths in exclusion patterns to relative paths
    based on the project root.
    """
    pattern = pattern.replace("\\", "/")
    if os.path.isabs(pattern):
        root_path_normalized = os.path.abspath(root_path).replace("\\", "/")
        if pattern.lower().startswith(root_path_normalized.lower()):
            try:
                relative_path = os.path.relpath(pattern, root_path)
                return relative_path.replace("\\", "/")
            except ValueError:
                return pattern
        else:
            return pattern
    return pattern

def clean_content(content_lines):
    """
    Removes empty lines and lines containing only whitespace from the content.
    """
    content_str = "\n".join(content_lines)
    cleaned_lines = [line for line in content_str.splitlines() if line.strip()]
    return cleaned_lines

def get_exclusions(folder_path, output_filename):
    ignore_file_path = os.path.join(folder_path, '.contextignore')
    exclusions = []
    if os.path.exists(ignore_file_path):
        print(f"\nFound a '.contextignore' file. Loading its rules.")
        with open(ignore_file_path, 'r', encoding='utf-8') as f:
            raw_lines = [line.strip() for line in f if line.strip() and not line.startswith('#')]
            exclusions = [normalize_pattern(line, folder_path) for line in raw_lines]
        add_more = input("> Add more temporary exclusions for this run only? (y/n): ").strip().lower()
        if add_more == 'y':
            additional_str = input("  Enter additional items to skip (comma-separated, full paths allowed): ").strip()
            if additional_str:
                additional_list = [normalize_pattern(item.strip(), folder_path)
                                   for item in additional_str.split(',') if item.strip()]
                exclusions.extend(additional_list)
    else:
        print("\nNo '.contextignore' file found.")
        print("Choose an exclusion preset or enter a custom list:")
        print("  1. Android App Project")
        print("  2. Python Project")
        print("  3. Node.js Project")
        print("  4. Enter custom list manually")
        print("  5. None (include everything)")
        chosen_exclusions = None
        while chosen_exclusions is None:
            choice = input("Enter your choice (1-5): ").strip()
            if choice == '1': chosen_exclusions = ANDROID_EXCLUSIONS
            elif choice == '2': chosen_exclusions = PYTHON_EXCLUSIONS
            elif choice == '3': chosen_exclusions = NODE_EXCLUSIONS
            elif choice == '4':
                exclusions_str = input("Enter items to skip, comma-separated (full paths allowed): ").strip()
                chosen_exclusions = [normalize_pattern(item.strip(), folder_path)
                                     for item in exclusions_str.split(',') if item.strip()]
            elif choice == '5': chosen_exclusions = []
            else: print("Invalid choice. Please enter a number between 1 and 5.")
        exclusions = chosen_exclusions
        if exclusions:
            save_choice = input("\n> Save these exclusions to a .contextignore file for future use? (y/n): ").strip().lower()
            if save_choice == 'y':
                try:
                    with open(ignore_file_path, 'w', encoding='utf-8') as f:
                        # CHANGE 1: Updated the comment in the generated .contextignore file
                        f.write("# Generated by the Context Snapshot Script\n\n")
                        full_save_list = set(exclusions + ROOT_LEVEL_EXCLUSIONS)
                        for item in sorted(list(full_save_list)):
                            f.write(f"{item}\n")
                    print(f"✅ Successfully created '.contextignore' in the project root.")
                except Exception as e:
                    print(f"⚠️ Could not create .contextignore file: {e}")
    final_exclusions = set(exclusions)
    final_exclusions.update(ROOT_LEVEL_EXCLUSIONS)
    final_exclusions.add('.contextignore')
    final_exclusions.add(output_filename)
    return list(final_exclusions)

def is_excluded(full_path, exclusions, root_path):
    basename_lower = os.path.basename(full_path).lower()
    relative_path_lower = os.path.relpath(full_path, root_path).replace("\\", "/").lower()
    for pattern in exclusions:
        pattern_lower = pattern.lower().replace("\\", "/")
        if fnmatch.fnmatch(basename_lower, pattern_lower):
            return True
        if fnmatch.fnmatch(relative_path_lower, pattern_lower):
            return True
    return False

def is_binary_file(filepath):
    try:
        with open(filepath, 'rb') as f:
            return b'\x00' in f.read(1024)
    except Exception:
        return True

def update_gitignore(folder_path, output_filename):
    """Checks for .gitignore and adds this script's files to it if they don't exist."""
    gitignore_path = os.path.join(folder_path, '.gitignore')
    # CHANGE 2: Updated the comment for the .gitignore entries
    entries_to_add = {'# === Context Snapshot Files ===', output_filename, '.contextignore'}

    if not os.path.exists(gitignore_path):
        return # Do nothing if .gitignore doesn't exist

    try:
        with open(gitignore_path, 'r', encoding='utf-8') as f:
            existing_entries = {line.strip() for line in f}

        missing_entries = entries_to_add - existing_entries

        if missing_entries:
            with open(gitignore_path, 'a', encoding='utf-8') as f:
                if os.path.getsize(gitignore_path) > 0:
                    f.write('\n')
                if '# === Context Snapshot Files ===' in missing_entries:
                    f.write('# === Context Snapshot Files ===\n')
                if output_filename in missing_entries:
                    f.write(f'{output_filename}\n')
                if '.contextignore' in missing_entries:
                    f.write('.contextignore\n')
            print("✅ Updated .gitignore with script-generated file paths.")
    except Exception as e:
        print(f"⚠️ Could not update .gitignore file: {e}")

def _generate_tree_recursive(startpath, root_path, exclusions, prefix, files_to_process):
    """
    A recursive helper function to build the directory tree correctly.
    """
    tree_lines = []
    
    try:
        all_item_names = sorted(os.listdir(startpath), key=str.lower)
    except OSError:
        return [], files_to_process

    items_to_display = []
    for name in all_item_names:
        full_path = os.path.join(startpath, name)
        is_skipped = is_excluded(full_path, exclusions, root_path)
        is_dir = os.path.isdir(full_path)
        items_to_display.append({'name': name, 'path': full_path, 'skipped': is_skipped, 'dir': is_dir})

    for i, item in enumerate(items_to_display):
        is_last = (i == len(items_to_display) - 1)
        connector = '└─ ' if is_last else '├─ '
        
        suffix = ""
        if item['dir']:
            suffix += "/"
        if item['skipped']:
            suffix += " [skipped]"

        tree_lines.append(f"{prefix}{connector}{item['name']}{suffix}")

        if item['dir'] and not item['skipped']:
            new_prefix = prefix + ('    ' if is_last else '│   ')
            sub_tree, files_to_process = _generate_tree_recursive(
                item['path'],
                root_path,
                exclusions,
                new_prefix,
                files_to_process
            )
            tree_lines.extend(sub_tree)
        elif not item['dir'] and not item['skipped']:
            files_to_process.append(item['path'])

    return tree_lines, files_to_process

def generate_tree(startpath, exclusions):
    """
    Kicks off the recursive tree generation.
    """
    tree_lines, files_to_process = _generate_tree_recursive(startpath, startpath, exclusions, "", [])
    return "\n".join(tree_lines), files_to_process

def get_version_and_content(filepath):
    """Reads an existing context file, returning its version and content separately."""
    if not os.path.exists(filepath):
        return "1.0", None
    with open(filepath, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    version_line = lines[0] if lines else ""
    match = re.search(r"(\d+\.\d+)", version_line)
    if match:
        version = match.group(1)
        content = "".join(lines[1:])
        return version, content
    else:
        return "1.0", "".join(lines)

def main():
    # CHANGE 3: Updated the main title of the script
    print("--- Context Snapshot Generator ---")
    folder_path = None
    while folder_path is None:
        path_input = input("Enter the full path of the folder to map: ").strip()
        if os.path.isdir(path_input):
            folder_path = os.path.abspath(path_input)
        else:
            print("Error: Not a valid directory. Try again.")
    output_filename = "project_context.txt"
    output_path = os.path.join(folder_path, output_filename)
    update_gitignore(folder_path, output_filename)
    exclusions = get_exclusions(folder_path, output_filename)
    print(f"\nUsing exclusions: {', '.join(sorted(exclusions)) if exclusions else 'None'}")
    print("\nProcessing... this may take a moment for large projects.")
    try:
        tree_string, files_to_read = generate_tree(folder_path, exclusions)
        raw_content = [
            "PROJECT FILE MAP:",
            "=================",
            f"Root: {folder_path}",
            "",
            tree_string,
            "==============",
            "FILE CONTENTS:",
        ]

        files_by_directory = defaultdict(list)
        for file_path in files_to_read:
            directory = os.path.dirname(file_path)
            files_by_directory[directory].append(file_path)

        for directory, files in sorted(files_by_directory.items()):
            all_files_are_binary = all(is_binary_file(f) for f in files)

            if all_files_are_binary and len(files) > 1:
                relative_path = os.path.relpath(directory, folder_path).replace(os.sep, '/')
                raw_content.extend([
                    "",
                    "-------",
                    f"PATH: {relative_path}/",
                    "-------",
                    f"[{len(files)} binary files skipped]"
                ])
            else:
                for file_path in sorted(files):
                    relative_path = os.path.relpath(file_path, folder_path).replace(os.sep, '/')
                    raw_content.extend([
                        "",
                        "-------",
                        f"FILE: {relative_path}",
                        "-------"
                    ])
                    if is_binary_file(file_path):
                        raw_content.append("[Binary file skipped]")
                        continue
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            raw_content.append(f.read())
                    except Exception as e:
                        raw_content.append(f"[Could not read file: {e}]")

        final_cleaned_lines = clean_content(raw_content)
        new_content_str = "\n".join(final_cleaned_lines)
        current_version_str, old_content_str = get_version_and_content(output_path)
        new_version_str = current_version_str
        if old_content_str is None:
            print(f"No existing '{output_filename}' found. Creating new file with version 1.0.")
            new_version_str = "1.0"
        elif old_content_str.strip() != new_content_str.strip():
            major, minor = map(int, current_version_str.split('.'))
            minor += 1
            new_version_str = f"{major}.{minor}"
            print(f"Project has changed. Updating version from {current_version_str} to {new_version_str}.")
        else:
            print(f"No changes detected. Version {current_version_str} remains the same.")
            
        # CHANGE 4: Updated the version header in the output file
        version_header = f"# This Dir Context Snapshot Version: {new_version_str}"
        final_output = f"{version_header}\n\n" + new_content_str
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(final_output)
        print(f"\n✅ Success! Output file created at: {output_path}")
    except Exception as e:
        print(f"\n❌ Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()